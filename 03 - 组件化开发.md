# 组件化开发

## 内容概述

- 认识组件化
- 注册组件
- 组件其他补充
- 组件数据存放
- 父子组件通信
- 父级向子级传递
- 子级向父级传递
- 插槽 slot

## 认识组件化

### 什么是组件化？

- 人面对复杂问题的处理方式：
  - 任何一个人处理信息的逻辑能力都是有限的
  - 所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。
  - 但是，我们人有一种天生的能力，就是将问题进行拆解。
  - 如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。
- 组件化也是类似的思想：
  - 如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。
  - 但如果，我们讲一个页面拆分成一个个小的功能模块，每个功能模块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。
    ![1595490290_1_.jpg](https://i.loli.net/2020/07/23/HDrW74sSCyTmVIf.png)

### Vue 组件化思想

- 组件化是 Vue.js 中的重要思想

  - 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。
  - 任何的应用都会被抽象成一颗组件树。

  什么意思呢, 我们看下面这张图
  ![1595489136_1_.jpg](https://i.loli.net/2020/07/23/prg4tU8JOsvlxQH.png)

  假如你学过 vue 有可能我这里讲的组件创建和你们学过的不同,当然以后项目中常规创建组件方式也不这样,那为什么我还要和大家讲这种方式呢?

  因为我觉得这些是组件的基础,对以后自己写一些全局组件、指令、plugin（插件）会有帮助

- 组件化思想的应用：
  - 有了组件化的思想，我们在之后的开发中就要充分的利用它。
  - 尽可能的将页面拆分成一个个小的、可复用的组件。
  - 这样让我们的代码更加方便组织和管理，并且扩展性也更强。
    所以，组件化是 Vue 开发中，非常重要的思想。

## 注册组件

注册组件的基本步骤

- 组件的使用分成三个步骤：
  - 创建组件构造器
  - 注册组件
  - 使用组件

![1595489716_1_.jpg](https://i.loli.net/2020/07/23/JzPCKmxsUnE1bD5.png)

我们来看看通过代码如何注册组件

```html
<body>
  <div id="app">
    <!-- 3.使用组件 -->
    <my-cpn>111</my-cpn>
    <div>
      <my-cpn></my-cpn>
    </div>
  </div>
  <!-- 无效组件 -->
  <my-cpn></my-cpn>
  <script src="../../vue.js"></script>
  <script>
    //1.创建组件构造器对象
    //es6 字符串使用 `` 可换行
    //extend(亿克斯碳德)
    const cpn = Vue.extend({
      template: `
            <div>
            <h2>我是组件标题</h2>
            <p>这是一个组件</p>
            </div>
            `,
    })
    //2.注册组件  component(肯剖能特)
    //可以使用小驼峰也可以使用 杠 ‘-’
    Vue.component("my-cpn", cpn)

    const app = new Vue({
      el: "#app",
      data: {
        msg: "hello Vue.js",
      },
    })
  </script>
</body>
```

### 注册组件步骤解析

- Vue.extend()：

  - 调用 Vue.extend()创建的是一个组件构造器。
  - 通常在创建组件构造器时，传入 template 代表我们自定义组件的模板。
  - 该模板就是在使用到组件的地方，要显示的 HTML 代码。
  - 这里在补充一个点, extend 在 Java 中作用是什么?是不是继承的意思, 这里也可以把 extend 理解成继承扩展
  - 所以也可以把 vue 实例理解成一个组件树的树根(ROOT)
  - **所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根(ROOT)实例特有些选项除外)**

- Vue.component()：

  - 调用 Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。
  - 所以需要传递两个参数：1、注册组件的标签名 2、组件构造器 3.组件必须挂载在某个 Vue 实例下，否则它不会生效。
  - 上面代码我使用了三次<my-cpn></my-cpn>
  - 而第三次其实并没有生效

## 组件其它补充

### 全局组件和局部组件

- 当我们通过调用 Vue.component()注册组件时，组件的注册是全局的
  - 这意味着该组件可以在任意 Vue 示例下使用。
- 如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件

```html
<body>
  <div id="app">
    <!-- 3.使用组件 -->
    <my-cpn></my-cpn>
  </div>
  <div id="app1">
    <!-- 3.使用组件 -->
    <my-cpn></my-cpn>
  </div>

  <div id="app2">
    <!-- 私有组件 -->
    <my-cpn-privte></my-cpn-privte>
  </div>
  <script src="../../vue.js"></script>
  <script>
    //1.创建组件构造器对象
    //es6 字符串使用 `` 可换行
    const cpn = Vue.extend({
      template: `
              <div>
              <h2>我是组件标题</h2>
              <p>这是一个全局组件</p>
              </div>
              `,
    })
    const cpn2 = Vue.extend({
      template: `
              <div>
              <h2>我是组件标题</h2>
              <p>这是一个私有组件</p>
              </div>
              `,
    })

    //2.注册组件(全局组件，可以在多个vue实例下使用)
    Vue.component("my-cpn", cpn)

    const app = new Vue({
      el: "#app",
      data: {
        msg: "hello Vue.js",
      },
    })
    const app1 = new Vue({
      el: "#app1",
      data: {
        msg: "hello Vue.js",
      },
    })

    //局部组件
    const app2 = new Vue({
      el: "#app2",
      data: {
        msg: "hello Vue.js",
      },
      components: {
        "my-cpn-privte": cpn2,
      },
    })
  </script>
</body>
```

### 父组件和子组件

- 在前面我们看到了组件树：

  - 组件和组件之间存在层级关系
  - 而其中一种非常重要的关系就是父子组件的关系

我们来看通过代码如何组成的这种层级关系：

```html
<body>
  <div id="app">
    <!-- 使用组件 -->
    <my-father></my-father>
  </div>
  <script src="../../vue.js"></script>
  <script>
    //先构造子组件
    const son = Vue.extend({
      template: `
            <div>
            <h2>我是子组件</h2>
            </div>
            `,
    })
    //在构造父组件
    const father = Vue.extend({
      template: `
            <div>
            <h2>我是父组件</h2>
            <my-son></my-son>
            </div>
            `,
      components: {
        "my-son": son,
      },
    })
    //vue实例就是一个 ROOT 组件
    const app = new Vue({
      el: "#app", //绑定需要管理的element
      data: {
        msg: "hello Vue.js",
      },
      components: {
        "my-father": father,
      },
    })
  </script>
</body>
```

### 组件的语法糖（简写）注册方式

在上面注册组件的方式，可能会有些繁琐。
Vue 为了简化这个过程，提供了注册的语法糖。
主要是省去了调用 Vue.extend()的步骤，而是可以直接使用一个对象来代替。

下面直接看代码吧

```html
<body>
  <div id="app">
    <!-- 使用组件 -->
    <my-cpnf></my-cpnf>
  </div>
  <script src="../../vue.js"></script>
  <script>
    const app = new Vue({
      el: "#app",
      data: {
        msg: "hello Vue.js",
      },
      components: {
        "my-cpnf": {
          template: `
                    <div>
                    <h2>我是组件</h2>
                    <p>我是组件</p>
                    </div>
                    `,
        },
      },
    })
  </script>
</body>
```

### 模板的分离写法

刚才，我们通过语法糖简化了 Vue 组件的注册过程，另外还有一个地方的写法比较麻烦，就是 template 模块写法。
如果我们能将其中的 HTML 分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰。
Vue 提供了两种方案来定义 HTML 模块内容：

- 使用<script>标签
- 使用<template>标签

```html
<body>
  <div id="app">
    <my-script></my-script>
    <my-template></my-template>
  </div>

  <!-- 1.script 标签,类型必需是 text/x-template -->
  <script type="text/x-template" id="cpn">
    <!-- 创建组件时必须包含一个 root 标签 像是div,lable等-->
     <div>
         <h2>我是组件script</h2>
         <p>我是组件script</p>
     </div>
  </script>

  <!-- template 标签 -->
  <template id="cpn-template">
    <!-- 创建组件时必须包含一个 root 标签 像是div,lable等-->
    <div>
      <h2>我是组件template</h2>
      <p>我是组件template</p>
    </div>
  </template>

  <script src="../../vue.js"></script>
  <script>
    //
    Vue.component("my-script", {
      template: "#cpn",
    })
    Vue.component("my-template", {
      template: "#cpn-template",
    })
    const myApp = new Vue({
      el: "#app", //绑定需要管理的element
      data: {
        msg: "hello Vue.js",
      },
    })
  </script>
</body>
```

## 组件数据存放

### 组件可以访问 Vue 实例数据吗?

组件是一个单独功能模块的封装：
这个模块有属于自己的 HTML 模板，也应该有属性自己的数据 data。
组件中的数据是保存在哪里呢？顶层的 Vue 实例中吗？
我们先来测试一下，组件中能不能直接访问 Vue 实例中的 data

```html
<body>
  <div id="app">
    <my-script></my-script>
    <my-template></my-template>
  </div>

  <!-- 1.script 标签,类型必需是 text/x-template -->
  <script type="text/x-template" id="cpn">
    <div>
        <h2>{{title}}{{msg}}</h2>
        <p>我是组件script</p>
    </div>
  </script>

  <!-- template 标签 -->
  <template id="cpn-template">
    <div>
      <h2>我是组件template{{title}}</h2>
      <p>我是组件template</p>
    </div>
  </template>

  <script src="../../vue.js"></script>
  <script>
    //组件里面data必需是一个函数且返回一个对象，组件和VUE对象非常相似
    Vue.component("my-script", {
      template: "#cpn",
      data() {
        return {
          title: "我是组件里的title ",
        }
      },
    })
    Vue.component("my-template", {
      template: "#cpn-template",
    })
    const app = new Vue({
      el: "#app", //绑定需要管理的element
      data: {
        msg: "hello Vue.js",
      },
    })
  </script>
</body>
```

### 组件 data 为什么是函数呢?

为什么 data 在组件中必须是一个函数呢?

- 首先，如果不是一个函数，Vue 直接就会报错。
- 其次，原因是在于 Vue 让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。

```html
<body>
  <div id="app">
    <!-- 组件实例之间互不影响,数据不共享，因为data是个函数每次创建时都会返回一个新的对象 -->
    <my-template></my-template>
    <my-template></my-template>
  </div>

  <!-- template 标签 -->
  <template id="cpn-template">
    <div>
      <h1>{{title}}</h1>
      <h2>当前计数：{{counter}}</h2>
      <button @click="btnSubtract()">-</button>
      <button @click="btnAdd()">+</button>
    </div>
  </template>

  <script src="../../vue.js"></script>
  <script>
    //1.组件里面data必需是一个函数且返回一个对象，组件和VUE对象非常相似
    //2.组件里面methods与Vue相同，都是一个对象
    Vue.component("my-template", {
      template: "#cpn-template",
      data() {
        return {
          title: "我是组件里的title",
          counter: 0,
        }
      },
      methods: {
        btnAdd() {
          this.counter++
        },
        btnSubtract() {
          this.counter--
        },
      },
    })
    const app = new Vue({
      el: "#app", //绑定需要管理的element
      data: {
        msg: "hello Vue.js",
      },
    })
  </script>
</body>
```

## 父子组件通信

在上一个小节中，我们提到了子组件是不能引用父组件或者 Vue 实例的数据的。
但是，在开发中，往往一些数据确实需要从上层传递到下层：

- 比如在一个页面中，我们从服务器请求到了很多的数据。
  其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。
  这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件(父组件)将数据传递给小组件(子组件)。
- 如何进行父子组件间的通信呢？Vue 官方提到

  - 通过 props 向子组件传递数据
  - 通过事件向父组件发送消息

下面通过一张图片来描述父子组件的通讯
![1595509070_1_.jpg](https://i.loli.net/2020/07/23/FiYodVEyf2Iq63U.png)

### 父级向子级传递

#### props 基本用法

在组件中，使用选项 props 来声明需要从父级接收到的数据。
props 的值有两种方式：

- 方式一：字符串数组，数组中的字符串就是传递时的名称。
- 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。
  我们先来看一个最简单的 props 传递：

```html
<body>
  <div id="app">
    <!-- 使用组件 :props 里字段,若字段定义成驼峰,些处需要用'-'来分隔:pull-up-load-->
    <my-son :parentmsg="msg" easymsg="so easy"></my-son>
  </div>
  <script src="../../vue.js"></script>
  <script>
    //子组件
    const son = Vue.extend({
      template: `
            <div>
            <h2>我是父组件</h2>
            <p>我是父组件</p>
            <div>{{parentmsg}}</div>
            <div>{{easymsg}}</div>
            </div>`,
      props: ["parentmsg", "easymsg"],
      // props: {
      //   //当传为String是可以简写
      //   easymsg: "",
      //   //接收父组件参数定义
      //   //类型限制
      //   // parentmsg: String
      //   // parentmsg: [String,Number,自定义类型]
      //   parentmsg: {
      //     type: String,
      //     default: "default value",
      //     required: false, //是否为必填项
      //   },
      //   parentLists: {
      //     type: Array,
      //     default() {
      //       return []
      //     },
      //   },
      //   // 自定义验证
      //   parentvalue: {
      //     validator(value) {
      //       return value > 1
      //     },
      //   },
      // },
      data() {
        return {}
      },
      components: {},
    })
    //root
    const app = new Vue({
      el: "#app",
      data: {
        msg: "父组件传过来的MSG",
      },
      components: {
        "my-son": son,
      },
    })
  </script>
</body>
```

这里有个小坑就是小驼峰问题,直接看代码演示吧
但是真实项目中(CLI 项目)是不会出现这样的问题, CLI 帮我们解决了这样的问题

- 我们说过，除了 String 和 Array 之外，我们也可以使用对象，当需要对 props 进行类型等验证时，就需要对象写法了。
  验证都支持哪些数据类型呢？
  - String
  - Number
  - Boolean
  - Array
  - Object
  - Date
  - Function
  - Symbol

当我们有自定义构造函数时，验证也支持自定义的类型

```js
parentvalue: {
  validator(value) {
    return value > 1 //返回一个boolean类型
    }
}
```

### 子级向父级通讯

- props 用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或事件到父组件中。
- 我们应该如何处理呢？这个时候，我们需要使用自定义事件来完成。
- 什么时候需要自定义事件呢？
  - 当子组件需要向父组件传递数据时，就要用到自定义事件了。
  - 我们之前学习的 v-on 不仅仅可以用于监听 DOM 事件，也可以用于组件间的自定义事件。
- 自定义事件的流程：
  - 在子组件中，通过\$emit()来触发事件。
  - 在父组件中，通过 v-on 来监听子组件事件。

```html
<body>
  <div id="app">
    <!-- 注意这里的事件名称使用小写，后期使用脚手架时在使用驼峰 -->
    <my-son
      :tdata="rootData"
      @itemclick="onReceive"
      @itemclick1="onReceive1"
    ></my-son>

    <h2>接收子组件传过来的值</h2>
    <h2>{{receiveData}}</h2>
  </div>

  <!-- template 标签 -->
  <template id="son">
    <div>
      <h2>我是组件cpnTemplate</h2>
      <div>{{tdata}}</div>
      <p v-for="(item, index) in categories" :key="index">
        <button @click="btnClick(item)">{{item.name}}</button>
      </p>
      <!-- <h2>我的选择：<br />{{obj}}</h2> -->
    </div>
  </template>
  <script src="../../vue.js"></script>
  <script>
    //子组件
    const mySon = {
      template: "#son",
      data() {
        return {
          //凯特国瑞斯
          categories: [
            { id: "1", name: "热门" },
            { id: "2", name: "家用" },
            { id: "3", name: "数码" },
          ],
          obj: null,
        }
      },
      methods: {
        btnClick(item) {
          this.obj = item
          //使用 伊密特 向父组件发送事件请求，注意这里的事件名称使用小写
          //但是CLI项目中不会有小驼峰的问题
          this.$emit("itemclick", item)
          this.$emit("itemclick1", { name: "我是张无忌" })
        },
      },
      props: {
        tdata: {
          type: Object,
          default() {
            return { name: "template" }
          },
        },
      },
    }
    //父组件
    const app = new Vue({
      el: "#app", //绑定需要管理的element
      data: {
        msg: "hello Vue.js",
        rootData: {
          name: "张无忌",
          age: "18",
          height: "1.88",
        },
        receiveData: null,
      },
      components: {
        mySon, //此处使用语法糖写法(简写)
      },
      methods: {
        onReceive(item) {
          this.receiveData = item
        },
        onReceive1(item1) {
          console.log(item1)
          // this.receiveData = item
        },
      },
    })
  </script>
</body>
```

**注意:不要在子组件中直接修改父组件传过来的值**
